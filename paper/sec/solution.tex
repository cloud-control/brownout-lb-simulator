This section describe three different solutions for balancing the load
directed to self-adaptive brownout-compliant applications composed by
multiple replicas. The first two strategies are heuristic solution
that take into account the self-adaptivity of the replicas. The third
alternative is based on optimization theory, with the aim of providing
guarantees on the best possible behavior.

\subsection{Variational principle-based heuristic}

Our first solution is inspired by the predictive approach. In fact,
the core of the predictive solution is to examine the variation of the
involved quantities. While in its classical form, this solution relies
on variations of response times or connections per replica, our
solution is based on the how the control variables $\theta_i$ are
changing within each replica.

The approach determines the variation of the control variables
$\theta_i$ and corresponingly react. If the percentage of optional
content served is increasing, the replica is assumed to be less
loaded, and more traffic can be sent to it. On the contrary, when the
optional content diminish, the replica will receive less traffic, to
increase the control variable if possible.

The replica weights $w_i$ are initialized to $\frac{1}{n}$ where $n$
is the number of replicas. The load-balancer periodically updates the
values of the weights based on the values of $\theta_i$ received by
the replicas. At time $k$, denoting with $\Delta \theta_i (k)$ the
variation $\theta_i (k) - \theta_i (k-1)$, the solution computes a
potential weight $\tilde{w}_i(k+1)$ according to
\begin{equation}
  \tilde{w}_i(k+1) = w_i(k) \cdot 
\left[ 1 + \gamma_p \, \Delta \theta_i (k) + \gamma_i \, \theta_i (k) \right] ,
\label{eq:theta-diff}
\end{equation}
where $\gamma_p$ and $\gamma_i$ are constant gains, respectively
related to a proportional and an integral load-balancing action. As
calculated, $\tilde{w}_i$ values can be negative. This is clearly not
feasible, therefore negative values are truncated to a small but still
positive weight. Using a positive weight instead of zero allows us to
probe the replica and see whether it is favorably responding to new
incoming requests or not. Moreover, the computed values do not respect
the constraint that their sum is equal to 1, so they are then
re-scaled according to
\begin{equation}
  w_i (k) = \cfrac{\tilde{w}_i (k)}{\sum_i \tilde{w}_i (k)}.
\label{eq:theta-diff-rescale}
\end{equation}

Once $\gamma_p$ is fixed to a selected value, increasing the integral
gain $\gamma_i$ calls for a stronger action on the load-balancing
side, which means that the load-balancer would take decisions very
much influenced by the current values of $\theta_i$, therefore greatly
improving performance at the cost of a more nervous control action. On
the contrary, decreasing $\gamma_i$ would stabilize the control
signals, possibly losing performance due to a slower reaction
time. The choice of the integral gain allows to exploit the trade-off
between performance and robustness.

\subsection{Equality principle-based heuristic}

The second innovative policy presented here is based on the principle
that in the best conditions, every replica should have a similar
behavior, therefore the control variables $\theta_i$ should be as
close as possible to one another. This approach selects weights that
would encourage the control variables to converge to a single value.

The heuristic computes a potential weight $\tilde{w}_i(k+1)$ according
to
\begin{equation}
  \tilde{w}_i(k+1) = w_i(k) + \gamma_e 
\left[ \theta_i (k) - \cfrac{\sum_j \theta_j (k) }{n} \right] ,
\label{eq:equal-thetas}
\end{equation}
where $\gamma_e$ is a paramter of the algorithm and accounts for how
fast the algorithm should converge. The weights are simply modified
proportionally to the difference between the current control value and
the average control value set by the replicas. Clearly, the same
saturation and normalization described in Equation
\eqref{eq:theta-diff-rescale} has to be applied to the proposed
solution, to ensure that the sum of the weights is equal to one and
they have positive values --- i.e., that all the incoming traffic is
directed to the replicas and that each replica receives at least some
request.

\str{Comment on the parameter $\gamma_e$}

\subsection{Optimization based load-balancing}
\str{Find a name for it and describe it. Prove what we can prove about
  the solution.}

% \textcolor{red}{\textit{\textbf{Cristian:} Some stuff that might help
%     to devise a solution. It can be proven (i.e., I have the proof on
%     a piece of paper), that the effective service rate of a replica
%     is: $$\mu_{i,eff}=\frac{1}{\frac{1-\theta_i}{\mu_i}+\frac{\theta_i}{M_i}}$$
%     \\
%     The respose time of a replica, as per M/M/1 queues, is:
%     \\
%     $$t_i=\frac{1}{\mu_{i,eff}-\lambda_i}$$
%     \\
%     Knowing that the controller tries to maintain $t_i=\tau_i$, one
%     can compute $\theta_i$ by inverting the equation above.
% }}
	
% \textbf{Proof for effective service rate.} Let $x_i = 1/\mu_i$ be the service time of a request served with mandatory content and $X_i = 1/M_i$ be the service time of a request served with both mandatory and optional content. Let us compute the time required to serve a burst of $n$ requests, i.e., $n$ requests that arrive at the same time, with a dimmer value of $\theta_i$:

% $$t=n (1-\theta_i) x_i + n \theta_i X_i$$

% Hence, the effective service rate is:

% \begin{eqnarray*}
% \mu_{eff,i} & = & n/t \\
% & = & \frac{1}{(1-\theta_i) x_i + \theta_i X_i} \\
% & = & \frac{1}{\frac{1-\theta_i}{\mu_i} + \frac{\theta_i}{M_i}}
% \end{eqnarray*}

